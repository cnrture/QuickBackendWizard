package com.github.cnrture.quickbackendwizard.contents

// Controller Test Content
fun getControllerTestContent(
    packageName: String,
    entityName: String,
    controllerName: String,
    endpoint: String,
): String {
    return buildString {
        appendLine("package $packageName.controller")
        appendLine()
        appendLine("import com.fasterxml.jackson.databind.ObjectMapper")
        appendLine("import com.ninjasquad.springmockk.MockkBean")
        appendLine("import io.kotest.core.spec.style.DescribeSpec")
        appendLine("import io.kotest.matchers.shouldBe")
        appendLine("import io.mockk.every")
        appendLine("import org.springframework.beans.factory.annotation.Autowired")
        appendLine("import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest")
        appendLine("import org.springframework.http.MediaType")
        appendLine("import org.springframework.test.web.servlet.*")
        appendLine("import $packageName.common.ApiResponse")
        appendLine("import $packageName.entity.$entityName")
        appendLine("import $packageName.service.${entityName}Service")
        appendLine()
        appendLine("@WebMvcTest($controllerName::class)")
        appendLine("class ${controllerName}Test : DescribeSpec() {")
        appendLine()
        appendLine("    @Autowired")
        appendLine("    private lateinit var mockMvc: MockMvc")
        appendLine()
        appendLine("    @Autowired")
        appendLine("    private lateinit var objectMapper: ObjectMapper")
        appendLine()
        appendLine("    @MockkBean")
        appendLine("    private lateinit var service: ${entityName}Service")
        appendLine()
        appendLine("    init {")
        appendLine("        describe(\"$controllerName endpoints\") {")
        appendLine()
        appendLine("            context(\"GET /$endpoint\") {")
        appendLine("                it(\"should return list of ${entityName.lowercase()}s when found\") {")
        appendLine("                    // Given")
        appendLine("                    val ${entityName.lowercase()}List = listOf(")
        appendLine("                        create${entityName}(1L, \"Test $entityName 1\"),")
        appendLine("                        create${entityName}(2L, \"Test $entityName 2\")")
        appendLine("                    )")
        appendLine("                    val apiResponse = ApiResponse(")
        appendLine("                        success = true,")
        appendLine("                        message = \"Successfully fetched $entityName list\",")
        appendLine("                        data = ${entityName.lowercase()}List")
        appendLine("                    )")
        appendLine("                    every { service.getAll() } returns apiResponse")
        appendLine()
        appendLine("                    // When & Then")
        appendLine("                    mockMvc.get(\"/$endpoint\")")
        appendLine("                        .andExpect {")
        appendLine("                            status { isOk() }")
        appendLine("                            content { contentType(MediaType.APPLICATION_JSON) }")
        appendLine("                            jsonPath(\"$.success\") { value(true) }")
        appendLine("                            jsonPath(\"$.data.length()\") { value(2) }")
        appendLine("                        }")
        appendLine("                }")
        appendLine()
        appendLine("                it(\"should return no content when list is empty\") {")
        appendLine("                    // Given")
        appendLine("                    val apiResponse = ApiResponse(")
        appendLine("                        success = false,")
        appendLine("                        message = \"No ${entityName.lowercase()}s found\",")
        appendLine("                        data = emptyList<$entityName>()")
        appendLine("                    )")
        appendLine("                    every { service.getAll() } returns apiResponse")
        appendLine()
        appendLine("                    // When & Then")
        appendLine("                    mockMvc.get(\"/$endpoint\")")
        appendLine("                        .andExpect { status { isNoContent() } }")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"GET /$endpoint/{id}\") {")
        appendLine("                it(\"should return ${entityName.lowercase()} when found\") {")
        appendLine("                    // Given")
        appendLine("                    val ${entityName.lowercase()} = create${entityName}(1L, \"Test ${entityName}\")")
        appendLine("                    val apiResponse = ApiResponse(")
        appendLine("                        success = true,")
        appendLine("                        message = \"Successfully fetched $entityName\",")
        appendLine("                        data = ${entityName.lowercase()}")
        appendLine("                    )")
        appendLine("                    every { service.getById(1L) } returns apiResponse")
        appendLine()
        appendLine("                    // When & Then")
        appendLine("                    mockMvc.get(\"/$endpoint/1\")")
        appendLine("                        .andExpect {")
        appendLine("                            status { isOk() }")
        appendLine("                            content { contentType(MediaType.APPLICATION_JSON) }")
        appendLine("                            jsonPath(\"$.success\") { value(true) }")
        appendLine("                            jsonPath(\"$.data.id\") { value(1) }")
        appendLine("                        }")
        appendLine("                }")
        appendLine()
        appendLine("                it(\"should return 404 when ${entityName.lowercase()} not found\") {")
        appendLine("                    // Given")
        appendLine("                    val apiResponse = ApiResponse<$entityName>(")
        appendLine("                        success = false,")
        appendLine("                        message = \"$entityName not found with id: 999\",")
        appendLine("                        data = null")
        appendLine("                    )")
        appendLine("                    every { service.getById(999L) } returns apiResponse")
        appendLine()
        appendLine("                    // When & Then")
        appendLine("                    mockMvc.get(\"/$endpoint/999\")")
        appendLine("                        .andExpect { status { isNotFound() } }")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"POST /$endpoint\") {")
        appendLine("                it(\"should create new ${entityName.lowercase()}\") {")
        appendLine("                    // Given")
        appendLine("                    val newEntity = create${entityName}(null, \"New ${entityName}\")")
        appendLine("                    val savedEntity = create${entityName}(1L, \"New ${entityName}\")")
        appendLine("                    val apiResponse = ApiResponse(")
        appendLine("                        success = true,")
        appendLine("                        message = \"$entityName created successfully\",")
        appendLine("                        data = savedEntity")
        appendLine("                    )")
        appendLine("                    every { service.create(any()) } returns apiResponse")
        appendLine()
        appendLine("                    // When & Then")
        appendLine("                    mockMvc.post(\"/$endpoint\") {")
        appendLine("                        contentType = MediaType.APPLICATION_JSON")
        appendLine("                        content = objectMapper.writeValueAsString(newEntity)")
        appendLine("                    }.andExpect {")
        appendLine("                        status { isCreated() }")
        appendLine("                        content { contentType(MediaType.APPLICATION_JSON) }")
        appendLine("                        jsonPath(\"$.success\") { value(true) }")
        appendLine("                        jsonPath(\"$.data.id\") { value(1) }")
        appendLine("                    }")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"PUT /$endpoint/{id}\") {")
        appendLine("                it(\"should update existing ${entityName.lowercase()}\") {")
        appendLine("                    // Given")
        appendLine("                    val updatedEntity = create${entityName}(1L, \"Updated ${entityName}\")")
        appendLine("                    val apiResponse = ApiResponse(")
        appendLine("                        success = true,")
        appendLine("                        message = \"$entityName updated successfully\",")
        appendLine("                        data = updatedEntity")
        appendLine("                    )")
        appendLine("                    every { service.update(1L, any()) } returns apiResponse")
        appendLine()
        appendLine("                    // When & Then")
        appendLine("                    mockMvc.put(\"/$endpoint/1\") {")
        appendLine("                        contentType = MediaType.APPLICATION_JSON")
        appendLine("                        content = objectMapper.writeValueAsString(updatedEntity)")
        appendLine("                    }.andExpect {")
        appendLine("                        status { isOk() }")
        appendLine("                        content { contentType(MediaType.APPLICATION_JSON) }")
        appendLine("                        jsonPath(\"$.success\") { value(true) }")
        appendLine("                    }")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"DELETE /$endpoint/{id}\") {")
        appendLine("                it(\"should delete ${entityName.lowercase()} successfully\") {")
        appendLine("                    // Given")
        appendLine("                    val apiResponse = ApiResponse(")
        appendLine("                        success = true,")
        appendLine("                        message = \"$entityName deleted successfully\",")
        appendLine("                        data = true")
        appendLine("                    )")
        appendLine("                    every { service.deleteById(1L) } returns apiResponse")
        appendLine()
        appendLine("                    // When & Then")
        appendLine("                    mockMvc.delete(\"/$endpoint/1\")")
        appendLine("                        .andExpect { status { isNoContent() } }")
        appendLine("                }")
        appendLine("            }")
        appendLine("        }")
        appendLine("    }")
        appendLine()
        appendLine("    private fun create${entityName}(id: Long?, name: String) = ${entityName}(")
        appendLine("        id = id,")
        appendLine("        name = name,")
        appendLine("        // Add other properties as needed based on your entity")
        appendLine("    )")
        appendLine("}")
    }
}

// Service Test Content  
fun getServiceTestContent(
    packageName: String,
    entityName: String,
    serviceName: String,
    repositoryName: String,
): String {
    return buildString {
        appendLine("package $packageName.service")
        appendLine()
        appendLine("import io.kotest.core.spec.style.DescribeSpec")
        appendLine("import io.kotest.matchers.shouldBe")
        appendLine("import io.kotest.matchers.shouldNotBe")
        appendLine("import io.mockk.every")
        appendLine("import io.mockk.mockk")
        appendLine("import io.mockk.verify")
        appendLine("import java.util.*")
        appendLine("import $packageName.entity.$entityName")
        appendLine("import $packageName.repository.$repositoryName")
        appendLine()
        appendLine("class ${serviceName}Test : DescribeSpec({")
        appendLine()
        appendLine("    val repository = mockk<$repositoryName>()")
        appendLine("    val service = $serviceName(repository)")
        appendLine()
        appendLine("    describe(\"${serviceName}\") {")
        appendLine()
        appendLine("        context(\"getAll\") {")
        appendLine("            it(\"should return success response with ${entityName.lowercase()}s\") {")
        appendLine("                // Given")
        appendLine("                val ${entityName.lowercase()}List = listOf(")
        appendLine("                    create${entityName}(1L, \"Test 1\"),")
        appendLine("                    create${entityName}(2L, \"Test 2\")")
        appendLine("                )")
        appendLine("                every { repository.findAll() } returns ${entityName.lowercase()}List")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.getAll()")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe true")
        appendLine("                result.data shouldBe ${entityName.lowercase()}List")
        appendLine("                result.message shouldBe \"Successfully fetched $entityName list\"")
        appendLine("                verify { repository.findAll() }")
        appendLine("            }")
        appendLine()
        appendLine("            it(\"should return error response when repository throws exception\") {")
        appendLine("                // Given")
        appendLine("                every { repository.findAll() } throws RuntimeException(\"Database error\")")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.getAll()")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe false")
        appendLine("                result.data shouldBe emptyList()")
        appendLine("                result.message shouldBe \"Error fetching $entityName list: Database error\"")
        appendLine("            }")
        appendLine("        }")
        appendLine()
        appendLine("        context(\"getById\") {")
        appendLine("            it(\"should return success response when ${entityName.lowercase()} exists\") {")
        appendLine("                // Given")
        appendLine("                val ${entityName.lowercase()} = create${entityName}(1L, \"Test\")")
        appendLine("                every { repository.findById(1L) } returns Optional.of(${entityName.lowercase()})")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.getById(1L)")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe true")
        appendLine("                result.data shouldBe ${entityName.lowercase()}")
        appendLine("                result.message shouldBe \"Successfully fetched $entityName\"")
        appendLine("            }")
        appendLine()
        appendLine("            it(\"should return error response when ${entityName.lowercase()} not found\") {")
        appendLine("                // Given")
        appendLine("                every { repository.findById(999L) } returns Optional.empty()")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.getById(999L)")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe false")
        appendLine("                result.data shouldBe null")
        appendLine("                result.message shouldBe \"$entityName not found with id: 999\"")
        appendLine("            }")
        appendLine("        }")
        appendLine()
        appendLine("        context(\"create\") {")
        appendLine("            it(\"should create ${entityName.lowercase()} successfully\") {")
        appendLine("                // Given")
        appendLine("                val newEntity = create${entityName}(null, \"New Entity\")")
        appendLine("                val savedEntity = create${entityName}(1L, \"New Entity\")")
        appendLine("                every { repository.save(newEntity) } returns savedEntity")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.create(newEntity)")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe true")
        appendLine("                result.data shouldBe savedEntity")
        appendLine("                result.message shouldBe \"$entityName created successfully\"")
        appendLine("            }")
        appendLine()
        appendLine("            it(\"should return error response when save fails\") {")
        appendLine("                // Given")
        appendLine("                val newEntity = create${entityName}(null, \"New Entity\")")
        appendLine("                every { repository.save(newEntity) } throws RuntimeException(\"Save failed\")")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.create(newEntity)")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe false")
        appendLine("                result.data shouldBe null")
        appendLine("                result.message shouldBe \"Error creating $entityName: Save failed\"")
        appendLine("            }")
        appendLine("        }")
        appendLine()
        appendLine("        context(\"update\") {")
        appendLine("            it(\"should update ${entityName.lowercase()} successfully when exists\") {")
        appendLine("                // Given")
        appendLine("                val updateEntity = create${entityName}(null, \"Updated Entity\")")
        appendLine("                val savedEntity = create${entityName}(1L, \"Updated Entity\")")
        appendLine("                every { repository.existsById(1L) } returns true")
        appendLine("                every { repository.save(any()) } returns savedEntity")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.update(1L, updateEntity)")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe true")
        appendLine("                result.data shouldBe savedEntity")
        appendLine("                result.message shouldBe \"$entityName updated successfully\"")
        appendLine("            }")
        appendLine()
        appendLine("            it(\"should return error response when ${entityName.lowercase()} not found\") {")
        appendLine("                // Given")
        appendLine("                val updateEntity = create${entityName}(null, \"Updated Entity\")")
        appendLine("                every { repository.existsById(999L) } returns false")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.update(999L, updateEntity)")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe false")
        appendLine("                result.data shouldBe null")
        appendLine("                result.message shouldBe \"$entityName not found with id: 999\"")
        appendLine("            }")
        appendLine("        }")
        appendLine()
        appendLine("        context(\"deleteById\") {")
        appendLine("            it(\"should delete ${entityName.lowercase()} successfully when exists\") {")
        appendLine("                // Given")
        appendLine("                every { repository.existsById(1L) } returns true")
        appendLine("                every { repository.deleteById(1L) } returns Unit")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.deleteById(1L)")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe true")
        appendLine("                result.data shouldBe true")
        appendLine("                result.message shouldBe \"$entityName deleted successfully\"")
        appendLine("                verify { repository.deleteById(1L) }")
        appendLine("            }")
        appendLine()
        appendLine("            it(\"should return error response when ${entityName.lowercase()} not found\") {")
        appendLine("                // Given")
        appendLine("                every { repository.existsById(999L) } returns false")
        appendLine()
        appendLine("                // When")
        appendLine("                val result = service.deleteById(999L)")
        appendLine()
        appendLine("                // Then")
        appendLine("                result.success shouldBe false")
        appendLine("                result.data shouldBe false")
        appendLine("                result.message shouldBe \"$entityName not found with id: 999\"")
        appendLine("            }")
        appendLine("        }")
        appendLine("    }")
        appendLine("})")
        appendLine()
        appendLine("private fun create${entityName}(id: Long?, name: String) = ${entityName}(")
        appendLine("    id = id,")
        appendLine("    name = name")
        appendLine("    // Add other properties as needed based on your entity")
        appendLine(")")
    }
}

// Repository Test Content
fun getRepositoryTestContent(
    packageName: String,
    entityName: String,
    repositoryName: String,
    selectedDatabase: String = "postgresql",
): String {
    val dbConfig = getDatabaseTestConfig(selectedDatabase)

    return buildString {
        appendLine("package $packageName.repository")
        appendLine()
        appendLine("import io.kotest.core.spec.style.DescribeSpec")
        appendLine("import io.kotest.matchers.shouldBe")
        appendLine("import io.kotest.matchers.shouldNotBe")
        appendLine("import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest")
        appendLine("import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager")
        appendLine("import org.springframework.test.context.ActiveProfiles")

        // H2 doesn't need Testcontainers
        if (selectedDatabase != "h2") {
            appendLine("import org.testcontainers.containers.${getContainerClass(selectedDatabase)}")
            appendLine("import org.testcontainers.junit.jupiter.Container")
            appendLine("import org.testcontainers.junit.jupiter.Testcontainers")
        }

        appendLine("import $packageName.entity.$entityName")
        appendLine()
        appendLine("@DataJpaTest")
        appendLine("@ActiveProfiles(\"test\")")

        if (selectedDatabase != "h2") {
            appendLine("@Testcontainers")
        }

        appendLine("class ${repositoryName}Test : DescribeSpec() {")
        appendLine()

        // Only add container for non-H2 databases
        if (selectedDatabase != "h2") {
            appendLine("    companion object {")
            appendLine("        @Container")
            appendLine("        val database = ${getContainerClass(selectedDatabase)}(\"${dbConfig.containerImage}\")")
            appendLine("            .withDatabaseName(\"${dbConfig.databaseName}\")")
            appendLine("            .withUsername(\"${dbConfig.username}\")")
            appendLine("            .withPassword(\"${dbConfig.password}\")")
            appendLine("    }")
            appendLine()
        }

        appendLine("    private lateinit var testEntityManager: TestEntityManager")
        appendLine("    private lateinit var repository: $repositoryName")
        appendLine()
        appendLine("    init {")
        appendLine("        describe(\"${repositoryName}\") {")
        appendLine()
        appendLine("            context(\"findAll\") {")
        appendLine("                it(\"should return all ${entityName.lowercase()}s\") {")
        appendLine("                    // Given")
        appendLine("                    val entity1 = create${entityName}(\"Test 1\")")
        appendLine("                    val entity2 = create${entityName}(\"Test 2\")")
        appendLine("                    testEntityManager.persistAndFlush(entity1)")
        appendLine("                    testEntityManager.persistAndFlush(entity2)")
        appendLine()
        appendLine("                    // When")
        appendLine("                    val result = repository.findAll()")
        appendLine()
        appendLine("                    // Then")
        appendLine("                    result.size shouldBe 2")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"findById\") {")
        appendLine("                it(\"should return ${entityName.lowercase()} when exists\") {")
        appendLine("                    // Given")
        appendLine("                    val entity = create${entityName}(\"Test Entity\")")
        appendLine("                    val savedEntity = testEntityManager.persistAndFlush(entity)")
        appendLine()
        appendLine("                    // When")
        appendLine("                    val result = repository.findById(savedEntity.id!!)")
        appendLine()
        appendLine("                    // Then")
        appendLine("                    result.isPresent shouldBe true")
        appendLine("                    result.get().name shouldBe \"Test Entity\"")
        appendLine("                }")
        appendLine()
        appendLine("                it(\"should return empty when ${entityName.lowercase()} not exists\") {")
        appendLine("                    // When")
        appendLine("                    val result = repository.findById(999L)")
        appendLine()
        appendLine("                    // Then")
        appendLine("                    result.isPresent shouldBe false")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"save\") {")
        appendLine("                it(\"should save new ${entityName.lowercase()}\") {")
        appendLine("                    // Given")
        appendLine("                    val entity = create${entityName}(\"New Entity\")")
        appendLine()
        appendLine("                    // When")
        appendLine("                    val result = repository.save(entity)")
        appendLine()
        appendLine("                    // Then")
        appendLine("                    result.id shouldNotBe null")
        appendLine("                    result.name shouldBe \"New Entity\"")
        appendLine("                }")
        appendLine()
        appendLine("                it(\"should update existing ${entityName.lowercase()}\") {")
        appendLine("                    // Given")
        appendLine("                    val entity = create${entityName}(\"Original\")")
        appendLine("                    val savedEntity = testEntityManager.persistAndFlush(entity)")
        appendLine("                    testEntityManager.clear()")
        appendLine()
        appendLine("                    // When")
        appendLine("                    val updatedEntity = savedEntity.copy(name = \"Updated\")")
        appendLine("                    val result = repository.save(updatedEntity)")
        appendLine()
        appendLine("                    // Then")
        appendLine("                    result.id shouldBe savedEntity.id")
        appendLine("                    result.name shouldBe \"Updated\"")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"deleteById\") {")
        appendLine("                it(\"should delete ${entityName.lowercase()} when exists\") {")
        appendLine("                    // Given")
        appendLine("                    val entity = create${entityName}(\"To Delete\")")
        appendLine("                    val savedEntity = testEntityManager.persistAndFlush(entity)")
        appendLine()
        appendLine("                    // When")
        appendLine("                    repository.deleteById(savedEntity.id!!)")
        appendLine()
        appendLine("                    // Then")
        appendLine("                    val result = repository.findById(savedEntity.id!!)")
        appendLine("                    result.isPresent shouldBe false")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"existsById\") {")
        appendLine("                it(\"should return true when ${entityName.lowercase()} exists\") {")
        appendLine("                    // Given")
        appendLine("                    val entity = create${entityName}(\"Exists\")")
        appendLine("                    val savedEntity = testEntityManager.persistAndFlush(entity)")
        appendLine()
        appendLine("                    // When")
        appendLine("                    val result = repository.existsById(savedEntity.id!!)")
        appendLine()
        appendLine("                    // Then")
        appendLine("                    result shouldBe true")
        appendLine("                }")
        appendLine()
        appendLine("                it(\"should return false when ${entityName.lowercase()} not exists\") {")
        appendLine("                    // When")
        appendLine("                    val result = repository.existsById(999L)")
        appendLine()
        appendLine("                    // Then")
        appendLine("                    result shouldBe false")
        appendLine("                }")
        appendLine("            }")
        appendLine("        }")
        appendLine("    }")
        appendLine()
        appendLine("    private fun create${entityName}(name: String) = ${entityName}(")
        appendLine("        id = null,")
        appendLine("        name = name")
        appendLine("        // Add other properties as needed based on your entity")
        appendLine("    )")
        appendLine("}")
    }
}

// Integration Test Content
fun getIntegrationTestContent(
    packageName: String,
    entityName: String,
    endpoint: String,
    selectedDatabase: String = "postgresql",
): String {
    val dbConfig = getDatabaseTestConfig(selectedDatabase)

    return buildString {
        appendLine("package $packageName.integration")
        appendLine()
        appendLine("import com.fasterxml.jackson.databind.ObjectMapper")
        appendLine("import io.kotest.core.spec.style.DescribeSpec")
        appendLine("import io.kotest.matchers.shouldBe")
        appendLine("import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureWebMvc")
        appendLine("import org.springframework.boot.test.context.SpringBootTest")
        appendLine("import org.springframework.http.MediaType")
        appendLine("import org.springframework.test.context.ActiveProfiles")
        appendLine("import org.springframework.test.web.servlet.*")

        // H2 doesn't need Testcontainers
        if (selectedDatabase != "h2") {
            appendLine("import org.testcontainers.containers.${getContainerClass(selectedDatabase)}")
            appendLine("import org.testcontainers.junit.jupiter.Container")
            appendLine("import org.testcontainers.junit.jupiter.Testcontainers")
        }

        appendLine("import $packageName.entity.$entityName")
        appendLine("import $packageName.repository.${entityName}Repository")
        appendLine()
        appendLine("@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)")
        appendLine("@AutoConfigureWebMvc")
        appendLine("@ActiveProfiles(\"test\")")

        if (selectedDatabase != "h2") {
            appendLine("@Testcontainers")
        }

        appendLine("class ${entityName}IntegrationTest : DescribeSpec() {")
        appendLine()

        // Only add container for non-H2 databases
        if (selectedDatabase != "h2") {
            appendLine("    companion object {")
            appendLine("        @Container")
            appendLine("        val database = ${getContainerClass(selectedDatabase)}(\"${dbConfig.containerImage}\")")
            appendLine("            .withDatabaseName(\"${dbConfig.databaseName}\")")
            appendLine("            .withUsername(\"${dbConfig.username}\")")
            appendLine("            .withPassword(\"${dbConfig.password}\")")
            appendLine("    }")
            appendLine()
        }

        appendLine("    private lateinit var mockMvc: MockMvc")
        appendLine("    private lateinit var objectMapper: ObjectMapper")
        appendLine("    private lateinit var repository: ${entityName}Repository")
        appendLine()
        appendLine("    init {")
        appendLine("        describe(\"$entityName API Integration Tests\") {")
        appendLine()
        appendLine("            beforeEach {")
        appendLine("                repository.deleteAll()")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"Full CRUD operations\") {")
        appendLine("                it(\"should perform complete ${entityName.lowercase()} lifecycle\") {")
        appendLine("                    // Create")
        appendLine("                    val newEntity = create${entityName}(null, \"Integration Test Entity\")")
        appendLine("                    val createResult = mockMvc.post(\"/$endpoint\") {")
        appendLine("                        contentType = MediaType.APPLICATION_JSON")
        appendLine("                        content = objectMapper.writeValueAsString(newEntity)")
        appendLine("                    }.andExpect {")
        appendLine("                        status { isCreated() }")
        appendLine("                        jsonPath(\"$.success\") { value(true) }")
        appendLine("                    }.andReturn()")
        appendLine()
        appendLine("                    val createdEntity = objectMapper.readTree(createResult.response.contentAsString)")
        appendLine("                    val entityId = createdEntity.get(\"data\").get(\"id\").asLong()")
        appendLine()
        appendLine("                    // Read")
        appendLine("                    mockMvc.get(\"/$endpoint/\$entityId\")")
        appendLine("                        .andExpect {")
        appendLine("                            status { isOk() }")
        appendLine("                            jsonPath(\"$.success\") { value(true) }")
        appendLine("                            jsonPath(\"$.data.name\") { value(\"Integration Test Entity\") }")
        appendLine("                        }")
        appendLine()
        appendLine("                    // Update")
        appendLine("                    val updateEntity = create${entityName}(entityId, \"Updated Integration Test Entity\")")
        appendLine("                    mockMvc.put(\"/$endpoint/\$entityId\") {")
        appendLine("                        contentType = MediaType.APPLICATION_JSON")
        appendLine("                        content = objectMapper.writeValueAsString(updateEntity)")
        appendLine("                    }.andExpect {")
        appendLine("                        status { isOk() }")
        appendLine("                        jsonPath(\"$.success\") { value(true) }")
        appendLine("                        jsonPath(\"$.data.name\") { value(\"Updated Integration Test Entity\") }")
        appendLine("                    }")
        appendLine()
        appendLine("                    // Delete")
        appendLine("                    mockMvc.delete(\"/$endpoint/\$entityId\")")
        appendLine("                        .andExpect { status { isNoContent() } }")
        appendLine()
        appendLine("                    // Verify deletion")
        appendLine("                    mockMvc.get(\"/$endpoint/\$entityId\")")
        appendLine("                        .andExpect { status { isNotFound() } }")
        appendLine("                }")
        appendLine("            }")
        appendLine()
        appendLine("            context(\"List operations\") {")
        appendLine("                it(\"should handle multiple ${entityName.lowercase()}s\") {")
        appendLine("                    // Create multiple entities")
        appendLine("                    val entities = (1..3).map { i ->")
        appendLine("                        create${entityName}(null, \"Entity \$i\")")
        appendLine("                    }")
        appendLine()
        appendLine("                    entities.forEach { entity ->")
        appendLine("                        mockMvc.post(\"/$endpoint\") {")
        appendLine("                            contentType = MediaType.APPLICATION_JSON")
        appendLine("                            content = objectMapper.writeValueAsString(entity)")
        appendLine("                        }.andExpect { status { isCreated() } }")
        appendLine("                    }")
        appendLine()
        appendLine("                    // Get all")
        appendLine("                    mockMvc.get(\"/$endpoint\")")
        appendLine("                        .andExpect {")
        appendLine("                            status { isOk() }")
        appendLine("                            jsonPath(\"$.success\") { value(true) }")
        appendLine("                            jsonPath(\"$.data.length()\") { value(3) }")
        appendLine("                        }")
        appendLine("                }")
        appendLine("            }")
        appendLine("        }")
        appendLine("    }")
        appendLine()
        appendLine("    private fun create${entityName}(id: Long?, name: String) = ${entityName}(")
        appendLine("        id = id,")
        appendLine("        name = name")
        appendLine("        // Add other properties as needed based on your entity")
        appendLine("    )")
        appendLine("}")
    }
}

// Test Configuration Content
fun getTestConfigurationContent(packageName: String, selectedDatabase: String = "postgresql"): String {
    val dbConfig = getDatabaseTestConfig(selectedDatabase)

    return buildString {
        appendLine("package $packageName.config")
        appendLine()
        appendLine("import org.springframework.boot.test.context.TestConfiguration")
        appendLine("import org.springframework.context.annotation.Bean")
        appendLine("import org.springframework.context.annotation.Primary")

        // H2 doesn't need Testcontainers
        if (selectedDatabase != "h2") {
            appendLine("import org.testcontainers.containers.${getContainerClass(selectedDatabase)}")
        }

        appendLine()
        appendLine("@TestConfiguration")
        appendLine("class TestConfig {")
        appendLine()

        // Only add container for non-H2 databases
        if (selectedDatabase != "h2") {
            appendLine("    @Bean")
            appendLine("    @Primary")
            appendLine("    fun postgresContainer(): ${getContainerClass(selectedDatabase)}<*> {")
            appendLine("        return ${getContainerClass(selectedDatabase)}(\"${dbConfig.containerImage}\")")
            appendLine("            .withDatabaseName(\"${dbConfig.databaseName}\")")
            appendLine("            .withUsername(\"${dbConfig.username}\")")
            appendLine("            .withPassword(\"${dbConfig.password}\")")
            appendLine("            .also { it.start() }")
            appendLine("    }")
        }

        appendLine("}")
    }
}

// Test Application Properties Content
fun getTestApplicationPropertiesContent(selectedDatabase: String = "postgresql"): String {
    val dbConfig = getDatabaseTestConfig(selectedDatabase)

    return buildString {
        appendLine("# Test Configuration")
        if (selectedDatabase != "h2") {
            appendLine("spring.datasource.driver-class-name=org.testcontainers.jdbc.ContainerDatabaseDriver")
            appendLine("spring.datasource.url=jdbc:tc:${getJdbcUrl(selectedDatabase)}:///testdb")
        } else {
            appendLine("spring.datasource.url=jdbc:h2:mem:testdb")
        }
        appendLine("spring.datasource.username=${dbConfig.username}")
        appendLine("spring.datasource.password=${dbConfig.password}")
        appendLine()
        appendLine("spring.jpa.hibernate.ddl-auto=create-drop")
        appendLine("spring.jpa.show-sql=true")
        appendLine("spring.jpa.properties.hibernate.format_sql=true")
        appendLine()
        appendLine("logging.level.org.springframework.web=DEBUG")
        appendLine("logging.level.org.hibernate.SQL=DEBUG")
        appendLine("logging.level.org.hibernate.type.descriptor.sql=TRACE")
    }
}

data class DatabaseTestConfig(
    val containerImage: String,
    val databaseName: String,
    val username: String,
    val password: String,
)

fun getDatabaseTestConfig(selectedDatabase: String): DatabaseTestConfig {
    return when (selectedDatabase) {
        "postgresql" -> DatabaseTestConfig("postgres:15-alpine", "testdb", "test", "test")
        "mysql" -> DatabaseTestConfig("mysql:8.0", "testdb", "test", "test")
        "mariadb" -> DatabaseTestConfig("mariadb:10.9", "testdb", "test", "test")
        "h2" -> DatabaseTestConfig("", "testdb", "sa", "")
        else -> throw IllegalArgumentException("Unsupported database: $selectedDatabase")
    }
}

fun getContainerClass(selectedDatabase: String): String {
    return when (selectedDatabase) {
        "postgresql" -> "PostgreSQLContainer"
        "mysql" -> "MySQLContainer"
        "mariadb" -> "MariaDBContainer"
        else -> throw IllegalArgumentException("Unsupported database: $selectedDatabase")
    }
}

fun getJdbcUrl(selectedDatabase: String): String {
    return when (selectedDatabase) {
        "postgresql" -> "postgresql"
        "mysql" -> "mysql"
        "mariadb" -> "mariadb"
        else -> throw IllegalArgumentException("Unsupported database: $selectedDatabase")
    }
}