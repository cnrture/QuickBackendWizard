package com.github.cnrture.quickbackendwizard.contents

// JWT Utility Class
fun getJWTUtilContent(packageName: String): String {
    return buildString {
        appendLine("package $packageName.security")
        appendLine()
        appendLine("import io.jsonwebtoken.*")
        appendLine("import io.jsonwebtoken.security.Keys")
        appendLine("import org.slf4j.LoggerFactory")
        appendLine("import org.springframework.beans.factory.annotation.Value")
        appendLine("import org.springframework.security.core.userdetails.UserDetails")
        appendLine("import org.springframework.stereotype.Component")
        appendLine("import java.security.Key")
        appendLine("import java.util.*")
        appendLine()
        appendLine("@Component")
        appendLine("class JWTUtil {")
        appendLine()
        appendLine("    private val logger = LoggerFactory.getLogger(JWTUtil::class.java)")
        appendLine()
        appendLine("    @Value(\"\${jwt.secret:mySecretKey}\")")
        appendLine("    private lateinit var secret: String")
        appendLine()
        appendLine("    @Value(\"\${jwt.expiration:86400000}\") // 24 hours")
        appendLine("    private var jwtExpiration: Long = 0")
        appendLine()
        appendLine("    @Value(\"\${jwt.refresh-expiration:604800000}\") // 7 days")
        appendLine("    private var refreshExpiration: Long = 0")
        appendLine()
        appendLine("    private fun getSigningKey(): Key {")
        appendLine("        val keyBytes = secret.toByteArray()")
        appendLine("        return Keys.hmacShaKeyFor(keyBytes)")
        appendLine("    }")
        appendLine()
        appendLine("    fun extractUsername(token: String): String? {")
        appendLine("        return extractClaim(token) { it.subject }")
        appendLine("    }")
        appendLine()
        appendLine("    fun extractExpiration(token: String): Date? {")
        appendLine("        return extractClaim(token) { it.expiration }")
        appendLine("    }")
        appendLine()
        appendLine("    fun <T> extractClaim(token: String, claimsResolver: (Claims) -> T): T? {")
        appendLine("        return try {")
        appendLine("            val claims = extractAllClaims(token)")
        appendLine("            claimsResolver(claims)")
        appendLine("        } catch (e: Exception) {")
        appendLine("            logger.error(\"Error extracting claim from token: \${e.message}\")")
        appendLine("            null")
        appendLine("        }")
        appendLine("    }")
        appendLine()
        appendLine("    private fun extractAllClaims(token: String): Claims {")
        appendLine("        return Jwts.parserBuilder()")
        appendLine("            .setSigningKey(getSigningKey())")
        appendLine("            .build()")
        appendLine("            .parseClaimsJws(token)")
        appendLine("            .body")
        appendLine("    }")
        appendLine()
        appendLine("    fun isTokenExpired(token: String): Boolean {")
        appendLine("        val expiration = extractExpiration(token)")
        appendLine("        return expiration?.before(Date()) ?: true")
        appendLine("    }")
        appendLine()
        appendLine("    fun generateToken(userDetails: UserDetails): String {")
        appendLine("        val claims = HashMap<String, Any>()")
        appendLine("        return createToken(claims, userDetails.username, jwtExpiration)")
        appendLine("    }")
        appendLine()
        appendLine("    fun generateRefreshToken(userDetails: UserDetails): String {")
        appendLine("        val claims = HashMap<String, Any>()")
        appendLine("        claims[\"type\"] = \"refresh\"")
        appendLine("        return createToken(claims, userDetails.username, refreshExpiration)")
        appendLine("    }")
        appendLine()
        appendLine("    private fun createToken(claims: Map<String, Any>, subject: String, expiration: Long): String {")
        appendLine("        return Jwts.builder()")
        appendLine("            .setClaims(claims)")
        appendLine("            .setSubject(subject)")
        appendLine("            .setIssuedAt(Date(System.currentTimeMillis()))")
        appendLine("            .setExpiration(Date(System.currentTimeMillis() + expiration))")
        appendLine("            .signWith(getSigningKey(), SignatureAlgorithm.HS512)")
        appendLine("            .compact()")
        appendLine("    }")
        appendLine()
        appendLine("    fun validateToken(token: String, userDetails: UserDetails): Boolean {")
        appendLine("        return try {")
        appendLine("            val username = extractUsername(token)")
        appendLine("            username == userDetails.username && !isTokenExpired(token)")
        appendLine("        } catch (e: Exception) {")
        appendLine("            logger.error(\"Token validation failed: \${e.message}\")")
        appendLine("            false")
        appendLine("        }")
        appendLine("    }")
        appendLine()
        appendLine("    fun isRefreshToken(token: String): Boolean {")
        appendLine("        return extractClaim(token) { it[\"type\"] } == \"refresh\"")
        appendLine("    }")
        appendLine("}")
    }
}

// User Entity for Authentication
fun getUserEntityContent(packageName: String): String {
    return buildString {
        appendLine("package $packageName.entity")
        appendLine()
        appendLine("import jakarta.persistence.*")
        appendLine("import jakarta.validation.constraints.Email")
        appendLine("import jakarta.validation.constraints.NotBlank")
        appendLine("import jakarta.validation.constraints.Size")
        appendLine("import org.springframework.security.core.GrantedAuthority")
        appendLine("import org.springframework.security.core.authority.SimpleGrantedAuthority")
        appendLine("import org.springframework.security.core.userdetails.UserDetails")
        appendLine()
        appendLine("@Entity")
        appendLine("@Table(name = \"users\")")
        appendLine("data class User(")
        appendLine("    @Id")
        appendLine("    @GeneratedValue(strategy = GenerationType.IDENTITY)")
        appendLine("    val id: Long? = null,")
        appendLine()
        appendLine("    @Column(unique = true, nullable = false)")
        appendLine("    @field:NotBlank(message = \"Username is required\")")
        appendLine("    @field:Size(min = 3, max = 50, message = \"Username must be between 3 and 50 characters\")")
        appendLine("    private val username: String,")
        appendLine()
        appendLine("    @Column(unique = true, nullable = false)")
        appendLine("    @field:Email(message = \"Email should be valid\")")
        appendLine("    @field:NotBlank(message = \"Email is required\")")
        appendLine("    val email: String,")
        appendLine()
        appendLine("    @Column(nullable = false)")
        appendLine("    @field:NotBlank(message = \"Password is required\")")
        appendLine("    @field:Size(min = 6, message = \"Password must be at least 6 characters\")")
        appendLine("    private val password: String,")
        appendLine()
        appendLine("    @Enumerated(EnumType.STRING)")
        appendLine("    @Column(nullable = false)")
        appendLine("    val role: Role = Role.USER,")
        appendLine()
        appendLine("    @Column(name = \"account_non_expired\")")
        appendLine("    private val accountNonExpired: Boolean = true,")
        appendLine()
        appendLine("    @Column(name = \"account_non_locked\")")
        appendLine("    private val accountNonLocked: Boolean = true,")
        appendLine()
        appendLine("    @Column(name = \"credentials_non_expired\")")
        appendLine("    private val credentialsNonExpired: Boolean = true,")
        appendLine()
        appendLine("    @Column(name = \"enabled\")")
        appendLine("    private val enabled: Boolean = true")
        appendLine(") : UserDetails {")
        appendLine()
        appendLine("    override fun getAuthorities(): Collection<GrantedAuthority> {")
        appendLine("        return listOf(SimpleGrantedAuthority(\"ROLE_\${role.name}\"))")
        appendLine("    }")
        appendLine()
        appendLine("    override fun getPassword(): String = password")
        appendLine("    override fun getUsername(): String = username")
        appendLine("    override fun isAccountNonExpired(): Boolean = accountNonExpired")
        appendLine("    override fun isAccountNonLocked(): Boolean = accountNonLocked")
        appendLine("    override fun isCredentialsNonExpired(): Boolean = credentialsNonExpired")
        appendLine("    override fun isEnabled(): Boolean = enabled")
        appendLine("}")
        appendLine()
        appendLine("enum class Role {")
        appendLine("    USER, ADMIN")
        appendLine("}")
    }
}

// Authentication DTOs
fun getAuthDTOsContent(packageName: String): String {
    return buildString {
        appendLine("package $packageName.dto.auth")
        appendLine()
        appendLine("import jakarta.validation.constraints.Email")
        appendLine("import jakarta.validation.constraints.NotBlank")
        appendLine("import jakarta.validation.constraints.Size")
        appendLine()
        appendLine("data class LoginRequest(")
        appendLine("    @field:NotBlank(message = \"Username is required\")")
        appendLine("    val username: String,")
        appendLine()
        appendLine("    @field:NotBlank(message = \"Password is required\")")
        appendLine("    val password: String")
        appendLine(")")
        appendLine()
        appendLine("data class RegisterRequest(")
        appendLine("    @field:NotBlank(message = \"Username is required\")")
        appendLine("    @field:Size(min = 3, max = 50, message = \"Username must be between 3 and 50 characters\")")
        appendLine("    val username: String,")
        appendLine()
        appendLine("    @field:Email(message = \"Email should be valid\")")
        appendLine("    @field:NotBlank(message = \"Email is required\")")
        appendLine("    val email: String,")
        appendLine()
        appendLine("    @field:NotBlank(message = \"Password is required\")")
        appendLine("    @field:Size(min = 6, message = \"Password must be at least 6 characters\")")
        appendLine("    val password: String")
        appendLine(")")
        appendLine()
        appendLine("data class AuthResponse(")
        appendLine("    val accessToken: String,")
        appendLine("    val refreshToken: String,")
        appendLine("    val tokenType: String = \"Bearer\",")
        appendLine("    val expiresIn: Long")
        appendLine(")")
        appendLine()
        appendLine("data class RefreshTokenRequest(")
        appendLine("    @field:NotBlank(message = \"Refresh token is required\")")
        appendLine("    val refreshToken: String")
        appendLine(")")
        appendLine()
        appendLine("data class UserResponse(")
        appendLine("    val id: Long,")
        appendLine("    val username: String,")
        appendLine("    val email: String,")
        appendLine("    val role: String")
        appendLine(")")
    }
}